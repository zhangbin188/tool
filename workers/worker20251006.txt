import { validate as validateUUID, stringify as stringifyUUID } from 'uuid';
import { connect } from 'cloudflare:sockets';

const CONSTANTS = {
  WS_READY_STATE_OPEN: 1,
  WS_READY_STATE_CLOSED: 3,
  PROXY_CMD_TCP: 1,
  PROXY_CMD_UDP: 2,
  UDP_ALLOWED_PORT: 53, 
  MIN_PROXY_HEADER_LEN: 24,
  DEFAULT_UUID: '194042fd-fc58-49ab-95b4-f394533912aa',
  RESPONSE_404_HTML: `
    <html>
      <head><title>404 Not Found</title></head>
      <body>
        <center><h1>404 Not Found</h1></center>
        <hr><center>nginx/1.23.4</center>
      </body>
    </html>
  `,
  DELAY_THRESHOLD: 20000, 
  DELAY_MS: 1
};

function safeCloseWebSocket(ws: WebSocket): void {
  try {
    if (ws.readyState !== CONSTANTS.WS_READY_STATE_CLOSED) {
      ws.close(1000, 'Normal closure'); 
    }
  } catch (error) {
    console.error('[safeCloseWebSocket] Error:', error);
  }
}

function base64ToArrayBuffer(base64Str: string): { earlyData?: ArrayBuffer; error?: Error } {
  if (!base64Str.trim()) return { error: null };

  try {
    const normalizedBase64 = base64Str.replace(/-/g, '+').replace(/_/g, '/');
    const paddedBase64 = normalizedBase64.padEnd(normalizedBase64.length + (4 - normalizedBase64.length % 4) % 4, '=');
    
    const decodedStr = atob(paddedBase64);
    const uint8Arr = new Uint8Array(decodedStr.length);
    
    for (let i = 0; i < decodedStr.length; i++) {
      uint8Arr[i] = decodedStr.charCodeAt(i);
    }
    
    return { earlyData: uint8Arr.buffer, error: null };
  } catch (error) {
    return { error: error as Error };
  }
}

function makeReadableWebSocketStream(
  ws: WebSocket,
  earlyDataHeader: string,
  log: (info: string, event?: unknown) => void
): ReadableStream<ArrayBuffer> {
  let isCanceled = false;
  let controller: ReadableStreamDefaultController<ArrayBuffer>;

  const { earlyData, error: earlyDataError } = base64ToArrayBuffer(earlyDataHeader);
  if (earlyDataError) {
    log('[makeReadableWebSocketStream] Invalid earlyDataHeader (base64)');
    safeCloseWebSocket(ws);
  }

  return new ReadableStream({
    start(c: ReadableStreamDefaultController<ArrayBuffer>): void {
      controller = c;

      if (earlyData && !isCanceled) {
        controller.enqueue(earlyData);
      }

      const handleMessage = (e: MessageEvent): void => {
        if (isCanceled || e.data instanceof ArrayBuffer === false) return;
        controller.enqueue(e.data);
      };

      const handleError = (e: Event): void => {
        log('[WebSocket] Error occurred');
        if (!isCanceled) {
          isCanceled = true;
          controller.error(e);
          safeCloseWebSocket(ws);
        }
      };

      const handleClose = (): void => {
        log('[WebSocket] Connection closed');
        if (!isCanceled) {
          isCanceled = true;
          controller.close();
        }
      };

      ws.addEventListener('message', handleMessage);
      ws.addEventListener('error', handleError);
      ws.addEventListener('close', handleClose);

      controller.signal.addEventListener('abort', () => {
        ws.removeEventListener('message', handleMessage);
        ws.removeEventListener('error', handleError);
        ws.removeEventListener('close', handleClose);
      });
    },

    pull(): Promise<void> {
      return Promise.resolve();
    },

    cancel(reason: unknown): void {
      log('[ReadableStream] Canceled', reason);
      if (!isCanceled) {
        isCanceled = true;
        safeCloseWebSocket(ws);
      }
    }
  });
}

interface ProxyHeaderResult {
  hasError: boolean;
  message?: string;
  portRemote?: number;
  addressRemote?: string;
  rawDataIndex?: number;
  proxyVersion?: Uint8Array;
  isUDP?: boolean;
}

function processProxyHeader(proxyBuffer: ArrayBuffer, userID: string): ProxyHeaderResult {
  if (proxyBuffer.byteLength < CONSTANTS.MIN_PROXY_HEADER_LEN) {
    return { hasError: true, message: 'Invalid proxy header (too short)' };
  }

  const uint8Buffer = new Uint8Array(proxyBuffer);
  const proxyVersion = uint8Buffer.subarray(0, 1);
  const userIDBuffer = uint8Buffer.subarray(1, 17);
  const optLength = uint8Buffer[17]; 
  const commandOffset = 18 + optLength;
  const command = uint8Buffer[commandOffset]; 

  if (stringifyUUID(userIDBuffer) !== userID) {
    return { hasError: true, message: 'Invalid proxy user ID' };
  }

  let isUDP = false;
  if (command === CONSTANTS.PROXY_CMD_TCP) {
    isUDP = false;
  } else if (command === CONSTANTS.PROXY_CMD_UDP) {
    isUDP = true;
  } else {
    return {
      hasError: true,
      message: `Unsupported command (${command}) - Only TCP(1)/UDP(2) allowed`
    };
  }

  const portOffset = commandOffset + 1;
  const portRemote = new DataView(proxyBuffer).getUint16(portOffset, false);

  const addressOffset = portOffset + 2;
  const addressType = uint8Buffer[addressOffset];
  let addressValue = '';
  let addressLength = 0;
  let rawDataIndex = addressOffset + 1; 

  switch (addressType) {
    case 1: 
      addressLength = 4;
      addressValue = uint8Buffer.subarray(rawDataIndex, rawDataIndex + addressLength).join('.');
      break;

    case 2: 
      addressLength = uint8Buffer[rawDataIndex];
      rawDataIndex += 1; 
      addressValue = new TextDecoder().decode(
        uint8Buffer.subarray(rawDataIndex, rawDataIndex + addressLength)
      );
      break;

    case 3: 
      addressLength = 16;
      const ipv6Parts: string[] = [];
      const ipv6View = new DataView(proxyBuffer, rawDataIndex, addressLength);
      for (let i = 0; i < 8; i++) {
        ipv6Parts.push(ipv6View.getUint16(i * 2, false).toString(16));
      }
      addressValue = ipv6Parts.join(':');
      break;

    default:
      return { hasError: true, message: `Invalid address type (${addressType})` };
  }

  if (!addressValue.trim()) {
    return { hasError: true, message: `Empty address (type: ${addressType})` };
  }

  rawDataIndex += addressLength;

  return {
    hasError: false,
    proxyVersion,
    isUDP,
    portRemote,
    addressRemote: addressValue,
    rawDataIndex
  };
}

export default {
  async fetch(
    request: Request,
    env: { UUID?: string },
    ctx: ExecutionContext
  ): Promise<Response> {
    let targetAddress = '';
    let targetPortLog = '';
    const userID = env.UUID || CONSTANTS.DEFAULT_UUID;
    const isUUIDValid = validateUUID(userID);

    const log = (info: string, event?: unknown): void => {
      const prefix = targetAddress ? `[${targetAddress}:${targetPortLog}]` : '[Worker]';
      console.log(`${prefix} ${info}`, event || '');
    };

    const upgradeHeader = request.headers.get('Upgrade');
    if (!upgradeHeader || upgradeHeader.toLowerCase() !== 'websocket') {
      log('Rejected non-WebSocket request');
      return new Response(CONSTANTS.RESPONSE_404_HTML, {
        status: 404,
        headers: {
          'Content-Type': 'text/html; charset=utf-8',
          'WWW-Authenticate': 'Basic',
          'X-Proxy-Type': 'Standard'
        }
      });
    }

    if (!isUUIDValid) {
      log('Invalid UUID in environment variables');
      return new Response('Invalid Proxy Configuration', { status: 500 });
    }

    const webSocketPair = new WebSocketPair();
    const [clientWs, proxyWs] = Object.values(webSocketPair);
    let remoteSocket: ReturnType<typeof connect> | null = null;
    let remoteReadyPromise = new Promise<ReturnType<typeof connect>>((resolve) => {
      remoteSocketResolve = resolve;
    });
    let remoteSocketResolve: (socket: ReturnType<typeof connect>) => void;

    proxyWs.accept();
    log('WebSocket connection accepted');

    const earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';
    const clientReadableStream = makeReadableWebSocketStream(proxyWs, earlyDataHeader, log);

    ctx.waitUntil(
      clientReadableStream
        .pipeTo(
          new WritableStream({
            async write(chunk: ArrayBuffer): Promise<void> {
              if (remoteSocket) {
                const writer = remoteSocket.writable.getWriter();
                await writer.write(chunk);
                writer.releaseLock();
                return;
              }

              const headerResult = processProxyHeader(chunk, userID);
              if (headerResult.hasError) {
                throw new Error(`Header parse failed: ${headerResult.message}`);
              }

              const { portRemote, addressRemote, rawDataIndex, isUDP } = headerResult;
              targetAddress = addressRemote!;
              targetPortLog = `${portRemote!}--${Math.random()} ${isUDP ? 'UDP' : 'TCP'}`;

              if (isUDP && portRemote !== CONSTANTS.UDP_ALLOWED_PORT) {
                throw new Error(`UDP proxy only allowed for DNS (port ${CONSTANTS.UDP_ALLOWED_PORT})`);
              }

              log(`Connecting to target: ${targetAddress}:${portRemote}`);
              remoteSocket = connect({ hostname: targetAddress, port: portRemote! });
              remoteSocketResolve(remoteSocket); 

              const rawData = chunk.slice(rawDataIndex!);
              if (rawData.byteLength > 0) {
                const writer = remoteSocket.writable.getWriter();
                await writer.write(rawData);
                writer.releaseLock();
              }
            },

            close(): void {
              log('Client stream closed');
              if (remoteSocket) remoteSocket.close();
            },

            abort(reason: unknown): void {
              log('Client stream aborted', reason);
              safeCloseWebSocket(proxyWs);
              if (remoteSocket) remoteSocket.close();
            }
          })
        )
        .catch((error) => {
          log('Client stream error', error);
          safeCloseWebSocket(proxyWs);
          if (remoteSocket) remoteSocket.close();
        })
    );

    ctx.waitUntil(
      (async () => {
        try {
          remoteSocket = await remoteReadyPromise;
          log('Target connection established');

          const proxyRespHeader = new Uint8Array([0, 0]);
          if (proxyWs.readyState === CONSTANTS.WS_READY_STATE_OPEN) {
            proxyWs.send(proxyRespHeader);
          }

          let sendCount = 0;
          await remoteSocket.readable.pipeTo(
            new WritableStream({
              async write(chunk: ArrayBuffer): Promise<void> {
                if (proxyWs.readyState !== CONSTANTS.WS_READY_STATE_OPEN) {
                  throw new Error('Client WebSocket closed');
                }

                if (sendCount++ > CONSTANTS.DELAY_THRESHOLD) {
                  await new Promise((resolve) => setTimeout(resolve, CONSTANTS.DELAY_MS));
                }

                proxyWs.send(chunk);
              },

              close(): void {
                log('Target stream closed');
                safeCloseWebSocket(proxyWs);
              },

              abort(reason: unknown): void {
                log('Target stream aborted', reason);
                safeCloseWebSocket(proxyWs);
                if (remoteSocket) remoteSocket.close();
              }
            })
          );
        } catch (error) {
          log('Target stream error', error);
          safeCloseWebSocket
