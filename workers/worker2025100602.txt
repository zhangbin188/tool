import { connect } from 'cloudflare:sockets';

// ç±»å‹å®šä¹‰
/**
 * @typedef {Object} ServerConfig
 * @property {string} hostname
 * @property {number} port
 * @property {string} original
 */

/**
 * @typedef {Object} ConnectionResult
 * @property {import("@cloudflare/workers-types").Socket} socket
 * @property {ServerConfig} server
 */

/**
 * @typedef {Object} VLHeaderResult
 * @property {boolean} hasError
 * @property {string} [message]
 * @property {number} [portRemote]
 * @property {string} [addressRemote]
 * @property {number} [rawDataIndex]
 * @property {Uint8Array} [VLVersion]
 * @property {boolean} [isUDP]
 * @property {number} [addressType]
 */

// é…ç½®ç®¡ç†
const config = {
  subPath: 'link',
  password: 'a123456',
  serverPool: ['13.230.34.30'],
  UUID: 'a486a5be-a6fc-4a42-8ec9-4b35161f4299',
  cfip: [
    'ip.sb', 'time.is', 'skk.moe', 'www.visa.com.tw', 
    'www.visa.com.hk', 'www.visa.com.sg', 'cf.090227.xyz',
    'cf.877774.xyz', 'cdns.doon.eu.org', 'cf.zhetengsha.eu.org'
  ],
  dnsResolver: 'https://sky.rethinkdns.com/1:-Pf_____9_8A_AMAIgE8kMABVDDmKOHTAKg=',
  
  // åˆå§‹åŒ–æ—¶ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
  init(env) {
    if (env.PROXYIP || env.proxyip || env.proxyIP) {
      this.serverPool = (env.PROXYIP || env.proxyip || env.proxyIP)
        .split(',')
        .map(s => s.trim())
        .filter(Boolean);
    }
    
    this.password = env.PASSWORD || env.PASSWD || env.password || this.password;
    this.subPath = env.SUB_PATH || env.subpath || this.subPath;
    this.UUID = env.UUID || env.uuid || env.AUTH || this.UUID;
    this.dnsResolver = env.DNS_RESOLVER || this.dnsResolver;
    
    // å¤„ç†é»˜è®¤subPath
    if (this.subPath === 'link' || this.subPath === '') {
      this.subPath = this.UUID;
    }
  }
};

// DNSç¼“å­˜
const dnsCache = new Map();
const DNS_CACHE_TTL = 300000; // 5åˆ†é’Ÿç¼“å­˜

// å·¥å…·å‡½æ•°
const utils = {
  /**
   * è§£ææœåŠ¡å™¨åœ°å€å’Œç«¯å£
   * @param {string} serverStr 
   * @returns {{hostname: string, port: number}}
   */
  parseServerAddress(serverStr) {
    const defaultPort = 443;
    let hostname = serverStr.trim();
    let port = defaultPort;
    
    if (hostname.includes('.tp')) {
      const portMatch = hostname.match(/\.tp(\d+)\./);
      if (portMatch) {
        port = parseInt(portMatch[1], 10) || defaultPort;
      }
    } else if (hostname.includes('[') && hostname.includes(']:')) {
      const parts = hostname.split(']:');
      port = parseInt(parts[1], 10) || defaultPort;
      hostname = parts[0] + ']';
    } else if (hostname.includes(':')) {
      const parts = hostname.split(':');
      port = parseInt(parts[parts.length - 1], 10) || defaultPort;
      hostname = parts.slice(0, -1).join(':');
    }
    
    return { hostname, port };
  },
  
  /**
   * è§£æä¸»æœºååˆ°IPåœ°å€ï¼ˆå¸¦ç¼“å­˜ï¼‰
   * @param {string} hostname 
   * @returns {Promise<string>}
   */
  async resolveHostname(hostname) {
    // æ£€æŸ¥æ˜¯å¦æ˜¯IPåœ°å€
    if (/^(\d{1,3}\.){3}\d{1,3}$/.test(hostname) || 
        /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(hostname)) {
      return hostname;
    }
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = dnsCache.get(hostname);
    if (cached && Date.now() < cached.expiry) {
      return cached.ip;
    }
    
    try {
      const dnsResponse = await fetch(
        `https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(hostname)}&type=A`,
        { headers: { 'Accept': 'application/dns-json' }, cf: { cacheTtl: 300 } }
      );
      
      if (dnsResponse.ok) {
        const dnsData = await dnsResponse.json();
        if (dnsData.Answer && dnsData.Answer.length > 0) {
          const ip = dnsData.Answer[0].data;
          // å­˜å…¥ç¼“å­˜
          dnsCache.set(hostname, { ip, expiry: Date.now() + DNS_CACHE_TTL });
          return ip;
        }
      }
      
      console.warn(`DNS resolution failed for ${hostname}, using original hostname`);
      return hostname;
    } catch (error) {
      console.warn(`DNS resolution error for ${hostname}:`, error);
      return hostname;
    }
  },
  
  /**
   * ç”ŸæˆéšæœºUser-Agent
   * @returns {string}
   */
  obfuscateUserAgent() {
    const userAgents = [
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0'
    ];
    return userAgents[Math.floor(Math.random() * userAgents.length)];
  },
  
  /**
   * å®‰å…¨å…³é—­WebSocket
   * @param {import("@cloudflare/workers-types").WebSocket} socket 
   */
  safeCloseWebSocket(socket) {
    try {
      if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CLOSING) {
        socket.close(1000, 'Normal closure');
      }
    } catch (error) {
      console.error('WebSocket close error:', error);
    }
  },
  
  /**
   * éªŒè¯UUIDæ ¼å¼
   * @param {string} id 
   * @returns {boolean}
   */
  isValidAUTH(id) {
    const idRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return idRegex.test(id);
  },
  
  /**
   * å°†äºŒè¿›åˆ¶æ•°æ®è½¬æ¢ä¸ºUUIDå­—ç¬¦ä¸²
   * @param {Uint8Array} arr 
   * @param {number} [offset=0] 
   * @returns {string}
   */
  stringifyUUID(arr, offset = 0) {
    const byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    
    const id = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + 
                byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" +
                byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" +
                byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" +
                byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" +
                byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + 
                byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + 
                byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    
    if (!this.isValidAUTH(id)) {
      throw new TypeError("Stringified id is invalid");
    }
    return id;
  },
  
  /**
   * Base64è½¬ArrayBuffer
   * @param {string} base64Str 
   * @returns {{earlyData: ArrayBuffer, error: Error|null}}
   */
  base64ToArrayBuffer(base64Str) {
    if (!base64Str) {
      return { earlyData: null, error: null };
    }
    
    try {
      base64Str = base64Str.replace(/-/g, '+').replace(/_/g, '/');
      const decode = atob(base64Str);
      const arrayBuffer = Uint8Array.from(decode, c => c.charCodeAt(0)).buffer;
      return { earlyData: arrayBuffer, error: null };
    } catch (error) {
      return { earlyData: null, error };
    }
  }
};

// ç½‘ç»œè¿æ¥ç®¡ç†
const connectionManager = {
  /**
   * å¸¦æ•…éšœè½¬ç§»çš„æœåŠ¡å™¨è¿æ¥
   * @returns {Promise<ConnectionResult>}
   */
  async connectWithFailover() {
    const validServers = config.serverPool.filter(server => server && server.trim() !== '');
    const allServers = [...validServers, 'Kr.tp50000.netlib.re'];
    let lastError = null;
    
    for (const serverStr of allServers) {
      try {
        const { hostname, port } = utils.parseServerAddress(serverStr);
        const resolvedHostname = await utils.resolveHostname(hostname);
        
        const socket = await connect({
          hostname: resolvedHostname,
          port: port,
        });
        
        return {
          socket,
          server: {
            hostname: resolvedHostname,
            port: port,
            original: serverStr
          }
        };
      } catch (error) {
        lastError = error;
        continue;
      }
    }
    
    throw new Error(`All servers connect failed: ${lastError?.message || 'Unknown error'}`);
  },
  
  /**
   * å¤„ç†TCPå‡ºç«™è¿æ¥
   * @param {{value: import("@cloudflare/workers-types").Socket|null}} remoteSocket 
   * @param {string} addressRemote 
   * @param {number} portRemote 
   * @param {ArrayBuffer} rawClientData 
   * @param {import("@cloudflare/workers-types").WebSocket} webSocket 
   * @param {Uint8Array} VLResponseHeader 
   */
  async handleTCPOutBound(remoteSocket, addressRemote, portRemote, rawClientData, webSocket, VLResponseHeader) {
    /**
     * è¿æ¥å¹¶å‘é€æ•°æ®
     * @param {string} address 
     * @param {number} port 
     * @returns {Promise<import("@cloudflare/workers-types").Socket>}
     */
    async function connectAndWrite(address, port) {
      try {
        const tcpSocket = connect({
          hostname: address,
          port: port,
        });
        
        remoteSocket.value = tcpSocket;
        
        const writer = tcpSocket.writable.getWriter();
        await writer.write(rawClientData);
        writer.releaseLock();
        
        return tcpSocket;
      } catch (connectError) {
        throw connectError;
      }
    }
    
    /** é‡è¯•è¿æ¥ */
    async function retry() {
      try {
        const { socket: tcpSocket } = await this.connectWithFailover();
        remoteSocket.value = tcpSocket;
        
        const writer = tcpSocket.writable.getWriter();
        await writer.write(rawClientData);
        writer.releaseLock();
        
        // ç›‘å¬socketå…³é—­ï¼ŒåŒæ­¥å…³é—­WebSocket
        tcpSocket.closed
          .catch(error => console.error('TCP socket error:', error))
          .finally(() => utils.safeCloseWebSocket(webSocket));
          
        this.remoteSocketToWS(tcpSocket, webSocket, VLResponseHeader);
      } catch (retryError) {
        console.error('All servers connect failed:', retryError.message);
        utils.safeCloseWebSocket(webSocket);
      }
    }
    
    try {
      // é¦–å…ˆå°è¯•ç›´æ¥è¿æ¥ç›®æ ‡åœ°å€
      const tcpSocket = await connectAndWrite(addressRemote, portRemote);
      
      // ç›‘å¬socketå…³é—­ï¼ŒåŒæ­¥å…³é—­WebSocket
      tcpSocket.closed
        .catch(error => console.error('TCP socket error:', error))
        .finally(() => utils.safeCloseWebSocket(webSocket));
        
      this.remoteSocketToWS(tcpSocket, webSocket, VLResponseHeader);
    } catch (connectError) {
      console.log(`Direct connect failed, try to use failover: ${addressRemote}:${portRemote}`);
      await retry.call(this);
    }
  },
  
  /**
   * å¤„ç†UDPå‡ºç«™è¿æ¥ï¼ˆä»…æ”¯æŒDNSï¼‰
   * @param {import("@cloudflare/workers-types").WebSocket} webSocket 
   * @param {Uint8Array} VLResponseHeader 
   * @returns {Promise<{write: (chunk: ArrayBuffer) => Promise<void>}>}
   */
  async handleUDPOutBound(webSocket, VLResponseHeader) {
    let isVLHeaderSent = false;
    
    // åˆ›å»ºè½¬æ¢æµå¤„ç†UDPæ•°æ®åŒ…
    const transformStream = new TransformStream({
      transform(chunk, controller) {
        let index = 0;
        const chunkArray = new Uint8Array(chunk);
        
        while (index < chunkArray.byteLength) {
          if (index + 2 > chunkArray.byteLength) break;
          
          // è¯»å–é•¿åº¦
          const length = (chunkArray[index] << 8) | chunkArray[index + 1];
          index += 2;
          
          if (index + length > chunkArray.byteLength) break;
          
          // æå–UDPåŒ…
          const udpData = chunkArray.slice(index, index + length);
          controller.enqueue(udpData.buffer);
          
          index += length;
        }
      }
    });
    
    // å¤„ç†DNSæŸ¥è¯¢å¹¶è¿”å›ç»“æœ
    transformStream.readable.pipeTo(new WritableStream({
      async write(chunk) {
        try {
          const resp = await fetch(config.dnsResolver, {
            method: 'POST',
            headers: { 'content-type': 'application/dns-message' },
            body: chunk,
            cf: { cacheTtl: 60 }
          });
          
          if (!resp.ok) throw new Error(`DNS request failed: ${resp.status}`);
          
          const dnsQueryResult = await resp.arrayBuffer();
          const udpSize = dnsQueryResult.byteLength;
          const udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]);
          
          if (webSocket.readyState === WebSocket.OPEN) {
            const responseData = isVLHeaderSent 
              ? new Blob([udpSizeBuffer, dnsQueryResult])
              : new Blob([VLResponseHeader, udpSizeBuffer, dnsQueryResult]);
              
            webSocket.send(await responseData.arrayBuffer());
            isVLHeaderSent = true;
          }
        } catch (error) {
          console.error('DNS processing error:', error);
          utils.safeCloseWebSocket(webSocket);
        }
      }
    })).catch(error => {
      console.error('UDP stream error:', error);
      utils.safeCloseWebSocket(webSocket);
    });
    
    const writer = transformStream.writable.getWriter();
    
    return {
      write: async (chunk) => {
        if (webSocket.readyState !== WebSocket.OPEN) {
          writer.releaseLock();
          return;
        }
        
        try {
          await writer.write(chunk);
        } catch (error) {
          console.error('UDP write error:', error);
          writer.releaseLock();
          utils.safeCloseWebSocket(webSocket);
        }
      }
    };
  },
  
  /**
   * å°†è¿œç¨‹Socketæ•°æ®è½¬å‘åˆ°WebSocket
   * @param {import("@cloudflare/workers-types").Socket} remoteSocket 
   * @param {import("@cloudflare/workers-types").WebSocket} webSocket 
   * @param {Uint8Array} VLResponseHeader 
   */
  async remoteSocketToWS(remoteSocket, webSocket, VLResponseHeader) {
    let VLHeader = VLResponseHeader;
    let hasIncomingData = false;
    
    try {
      await remoteSocket.readable.pipeTo(new WritableStream({
        async write(chunk) {
          if (webSocket.readyState !== WebSocket.OPEN) {
            throw new Error('WebSocket is not open');
          }
          
          hasIncomingData = true;
          
          if (VLHeader) {
            webSocket.send(await new Blob([VLHeader, chunk]).arrayBuffer());
            VLHeader = null;
          } else {
            webSocket.send(chunk);
          }
        }
      }));
    } catch (error) {
      console.error('remoteSocketToWS error:', error);
    } finally {
      utils.safeCloseWebSocket(webSocket);
    }
  }
};

// åè®®å¤„ç†
const vlProtocol = {
  /**
   * åˆ›å»ºWebSocketå¯è¯»æµ
   * @param {import("@cloudflare/workers-types").WebSocket} webSocket 
   * @param {string} earlyDataHeader 
   * @returns {ReadableStream}
   */
  makeReadableWebSocketStream(webSocket, earlyDataHeader) {
    let readableStreamCancel = false;
    
    return new ReadableStream({
      start(controller) {
        const messageHandler = (event) => {
          if (readableStreamCancel) return;
          controller.enqueue(event.data);
        };
        
        const closeHandler = () => {
          if (readableStreamCancel) return;
          controller.close();
        };
        
        const errorHandler = (err) => {
          controller.error(err);
        };
        
        webSocket.addEventListener('message', messageHandler);
        webSocket.addEventListener('close', closeHandler);
        webSocket.addEventListener('error', errorHandler);
        
        // å¤„ç†æ—©æœŸæ•°æ®
        const { earlyData, error } = utils.base64ToArrayBuffer(earlyDataHeader);
        if (error) {
          controller.error(error);
        } else if (earlyData) {
          controller.enqueue(earlyData);
        }
        
        // æ¸…ç†å‡½æ•°
        return () => {
          webSocket.removeEventListener('message', messageHandler);
          webSocket.removeEventListener('close', closeHandler);
          webSocket.removeEventListener('error', errorHandler);
        };
      },
      
      cancel(reason) {
        if (readableStreamCancel) return;
        readableStreamCancel = true;
        utils.safeCloseWebSocket(webSocket);
      }
    });
  },
  
  /**
   * å¤„ç†åè®®å¤´
   * @param {ArrayBuffer} VLBuffer 
   * @returns {Promise<VLHeaderResult>}
   */
  async processVLHeader(VLBuffer) {
    if (VLBuffer.byteLength < 24) {
      return { hasError: true, message: 'Invalid data length' };
    }
    
    try {
      const version = new Uint8Array(VLBuffer.slice(0, 1));
      const slicedBuffer = new Uint8Array(VLBuffer.slice(1, 17));
      const slicedBufferString = utils.stringifyUUID(slicedBuffer);
      
      // éªŒè¯ç”¨æˆ·
      const ids = config.UUID.includes(',') ? config.UUID.split(",").map(id => id.trim()) : [config.UUID];
      const isValidUser = ids.some(uuid => slicedBufferString === uuid);
      
      if (!isValidUser) {
        return { hasError: true, message: 'Invalid user' };
      }
      
      const optLength = new Uint8Array(VLBuffer.slice(17, 18))[0];
      const command = new Uint8Array(VLBuffer.slice(18 + optLength, 18 + optLength + 1))[0];
      
      // æ£€æŸ¥å‘½ä»¤ç±»å‹
      const isUDP = command === 2;
      if (![1, 2].includes(command)) {
        return { 
          hasError: true, 
          message: `Unsupported command: ${command}, supports 01-tcp, 02-udp`
        };
      }
      
      // è§£æç«¯å£
      const portIndex = 18 + optLength + 1;
      const portBuffer = VLBuffer.slice(portIndex, portIndex + 2);
      const portRemote = new DataView(portBuffer).getUint16(0);
      
      // è§£æåœ°å€
      let addressIndex = portIndex + 2;
      const addressType = new Uint8Array(VLBuffer.slice(addressIndex, addressIndex + 1))[0];
      let addressValue = '';
      let addressValueIndex = addressIndex + 1;
      let addressLength = 0;
      
      switch (addressType) {
        case 1: // IPv4
          addressLength = 4;
          addressValue = new Uint8Array(
            VLBuffer.slice(addressValueIndex, addressValueIndex + addressLength)
          ).join('.');
          break;
          
        case 2: // åŸŸå
          addressLength = new Uint8Array(
            VLBuffer.slice(addressValueIndex, addressValueIndex + 1)
          )[0];
          addressValueIndex += 1;
          addressValue = new TextDecoder().decode(
            VLBuffer.slice(addressValueIndex, addressValueIndex + addressLength)
          );
          break;
          
        case 3: // IPv6
          addressLength = 16;
          const dataView = new DataView(VLBuffer.slice(addressValueIndex, addressValueIndex + addressLength));
          const ipv6 = [];
          for (let i = 0; i < 8; i++) {
            ipv6.push(dataView.getUint16(i * 2).toString(16));
          }
          addressValue = ipv6.join(':');
          break;
          
        default:
          return { hasError: true, message: `Invalid address type: ${addressType}` };
      }
      
      if (!addressValue) {
        return { hasError: true, message: `Empty address for type: ${addressType}` };
      }
      
      return {
        hasError: false,
        addressRemote: addressValue,
        addressType,
        portRemote,
        rawDataIndex: addressValueIndex + addressLength,
        VLVersion: version,
        isUDP
      };
    } catch (error) {
      console.error('Error processing VL header:', error);
      return { hasError: true, message: `Header processing error: ${error.message}` };
    }
  }
};

// HTTPè¯·æ±‚å¤„ç†
const httpHandler = {
  /**
   * å¤„ç†WebSocketå‡çº§è¯·æ±‚
   * @param {Request} request 
   * @returns {Promise<Response>}
   */
  async handleWebSocket(request) {
    // åˆ›å»ºWebSocketå¯¹
    const webSocketPair = new WebSocketPair();
    const [client, webSocket] = Object.values(webSocketPair);
    webSocket.accept();
    
    const earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';
    const readableWebSocketStream = vlProtocol.makeReadableWebSocketStream(webSocket, earlyDataHeader);
    
    // è¿œç¨‹SocketåŒ…è£…å™¨
    const remoteSocketWapper = { value: null };
    let udpStreamWrite = null;
    let isDns = false;
    
    // ç®¡é“å¤„ç†
    readableWebSocketStream.pipeTo(new WritableStream({
      async write(chunk) {
        try {
          // å¤„ç†DNS
          if (isDns && udpStreamWrite) {
            return udpStreamWrite(chunk);
          }
          
          // å·²å»ºç«‹è¿æ¥ï¼Œç›´æ¥å†™å…¥
          if (remoteSocketWapper.value) {
            const writer = remoteSocketWapper.value.writable.getWriter();
            await writer.write(chunk);
            writer.releaseLock();
            return;
          }
          
          // å¤„ç†åè®®å¤´
          const headerResult = await vlProtocol.processVLHeader(chunk);
          if (headerResult.hasError) {
            throw new Error(headerResult.message);
          }
          
          // æå–å¿…è¦ä¿¡æ¯
          const { 
            portRemote = 443, 
            addressRemote = '', 
            rawDataIndex, 
            VLVersion = new Uint8Array([0, 0]),
            isUDP
          } = headerResult;
          
          // å¤„ç†UDPï¼ˆä»…æ”¯æŒDNSï¼‰
          if (isUDP) {
            if (portRemote !== 53) {
              throw new Error('Only DNS (port 53) is supported for UDP');
            }
            
            isDns = true;
            const { write } = await connectionManager.handleUDPOutBound(webSocket, VLVersion);
            udpStreamWrite = write;
            udpStreamWrite(chunk.slice(rawDataIndex));
            return;
          }
          
          // å¤„ç†TCP
          const rawClientData = chunk.slice(rawDataIndex);
          connectionManager.handleTCPOutBound(
            remoteSocketWapper, 
            addressRemote, 
            portRemote, 
            rawClientData, 
            webSocket, 
            VLVersion
          );
        } catch (error) {
          console.error('Stream write error:', error);
          utils.safeCloseWebSocket(webSocket);
        }
      },
      
      close() {
        console.log('Readable stream closed');
      },
      
      abort(reason) {
        console.log('Readable stream aborted:', reason);
        utils.safeCloseWebSocket(webSocket);
      }
    })).catch(error => {
      console.error('Stream pipe error:', error);
      utils.safeCloseWebSocket(webSocket);
    });
    
    return new Response(null, {
      status: 101,
      webSocket: client,
    });
  },
  
  /**
   * è·å–ä¸»é¡µ
   * @param {Request} request 
   * @returns {Response}
   */
  getHomePage(request) {
    const url = request.headers.get('Host');
    const baseUrl = `https://${url}`;
    const urlObj = new URL(request.url);
    const providedPassword = urlObj.searchParams.get('password');
    
    if (providedPassword) {
      return providedPassword === config.password 
        ? this.getMainPageContent(url, baseUrl)
        : this.getLoginPage(url, baseUrl, true);
    }
    
    return this.getLoginPage(url, baseUrl, false);
  },
  
  /**
   * è·å–ç™»å½•é¡µé¢
   * @param {string} url 
   * @param {string} baseUrl 
   * @param {boolean} showError 
   * @returns {Response}
   */
  getLoginPage(url, baseUrl, showError = false) {
    const html = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workers Service - ç™»å½•</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            overflow: hidden;
        }
        .login-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            width: 95%;
            text-align: center;
        }
        .logo {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .title { font-size: 1.8rem; margin-bottom: 8px; color: #2d3748; }
        .subtitle { color: #718096; margin-bottom: 30px; font-size: 1rem; }
        .form-group { margin-bottom: 20px; text-align: left; }
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }
        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .btn-login {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-login:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #e53e3e;
        }
        @media (max-width: 480px) {
            .login-container { padding: 30px 20px; margin: 10px; }
            .logo { font-size: 2.5rem; }
            .title { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <div class="login-container">
        <div class="logo">ğŸ”</div>
        <h1 class="title">Workers Service</h1>
        <p class="subtitle">è¯·è¾“å…¥å¯†ç ä»¥è®¿é—®æœåŠ¡</p>
        
        ${showError ? '<div class="error-message">å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•</div>' : ''}
        
        <form onsubmit="handleLogin(event)">
            <div class="form-group">
                <label for="password" class="form-label">å¯†ç </label>
                <input 
                    type="password" 
                    id="password" 
                    name="password" 
                    class="form-input" 
                    placeholder="è¯·è¾“å…¥å¯†ç "
                    required
                    autofocus
                >
            </div>
            <button type="submit" class="btn-login">ç™»å½•</button>
        </form>
        
    <script>
        function handleLogin(event) {
            event.preventDefault();
            const password = document.getElementById('password').value;
            const currentUrl = new URL(window.location);
            currentUrl.searchParams.set('password', password);
            window.location.href = currentUrl.toString();
        }
    </script>
</body>
</html>`;

    return new Response(html, {
      status: 200,
      headers: {
        'Content-Type': 'text/html;charset=utf-8',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
      },
    });
  },
  
  /**
   * è·å–ä¸»é¡µé¢å†…å®¹
   * @param {string} url 
   * @param {string} baseUrl 
   * @returns {Response}
   */
  getMainPageContent(url, baseUrl) {
    const html = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workers Service</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            overflow: hidden;
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 95%;
            max-height: 90vh;
            text-align: center;
            overflow-y: auto;
        }
        .logout-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f5f5f5;
            color: #ff6b6b;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .logo {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .title { font-size: 1.8rem; margin-bottom: 8px; color: #2d3748; }
        .subtitle { color: #718096; margin-bottom: 15px; font-size: 1rem; }
        .info-card {
            background: #f7fafc;
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }
        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }
        .info-item:last-child { border-bottom: none; }
        .label { font-weight: 600; color: #4a5568; }
        .value {
            color:rgb(20, 23, 29);
            font-family: 'Courier New', monospace;
            background: #edf2f7;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.8rem;
        }
        .status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #48bb78;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        @media (max-width: 768px) {
            .container { padding: 15px; margin: 10px; max-height: 95vh; }
            .info-item { flex-direction: column; align-items: flex-start; gap: 4px; }
            .value { word-break: break-all; }
        }
    </style>
</head>
<body>
    <button onclick="window.location.href='/'" class="logout-btn">
        <i class="fas fa-sign-out-alt"></i>
        <span>é€€å‡ºç™»å½•</span>
    </button>
    
    <div class="container">
        <div class="logo">ğŸš€</div>
        <h1 class="title">Workers Service</h1>
        <p class="subtitle">åŸºäº Cloudflare Workers çš„é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡</p>
        
        <div class="info-card">
            <div class="info-item">
                <span class="label">æœåŠ¡çŠ¶æ€</span>
                <span class="value"><span class="status"></span>è¿è¡Œä¸­</span>
            </div>
            <div class="info-item">
                <span class="label">ä¸»æœºåœ°å€</span>
                <span class="value">${url}</span>
            </div>
            <div class="info-item">
                <span class="label">UUID</span>
                <span class="value">${config.UUID}</span>
            </div>
        </div>
    </div>
</body>
</html>`;

    return new Response(html, {
      status: 200,
      headers: {
        'Content-Type': 'text/html;charset=utf-8',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
      },
    });
  },
  
  /**
   * å¤„ç†ä¼ªè£…é¡µé¢è¯·æ±‚
   * @param {Request} request 
   * @returns {Promise<Response>}
   */
  async handleFakePage(request) {
    const url = new URL(request.url);
    const randomSites = config.cfip.length > 0 ? config.cfip : [
      'ip.sb', 'time.is', 'www.apple.com', 'skk.moe',
      'www.visa.com.tw', 'www.github.com', 'www.ups.com',
      'www.tesla.com', 'www.microsoft.com', 'www.amazon.com'
    ];
    
    const randomSite = randomSites[Math.floor(Math.random() * randomSites.length)];
    const targetUrl = new URL(`https://${randomSite}${url.pathname}${url.search}`);
    
    // æ„å»ºè¯·æ±‚å¤´
    const headers = new Headers(request.headers);
    headers.set('User-Agent', utils.obfuscateUserAgent());
    headers.set('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8');
    headers.set('Accept-Language', 'zh-CN,zh;q=0.9,en;q=0.8');
    headers.set('Accept-Encoding', 'gzip, deflate, br');
    headers.set('DNT', '1');
    headers.set('Connection', 'keep-alive');
    headers.set('Upgrade-Insecure-Requests', '1');
    headers.set('Host', randomSite);
    
    // åˆ é™¤å¯èƒ½æš´éœ²ä»£ç†çš„å¤´
    headers.delete('X-Forwarded-For');
    headers.delete('X-Real-IP');
    
    try {
      const response = await fetch(targetUrl, {
        method: request.method,
        headers: headers,
        body: request.body,
        redirect: 'follow',
        cf: { cacheTtl: 300 }
      });
      
      // å¤åˆ¶å“åº”å¹¶è¿‡æ»¤æ•æ„Ÿå¤´
      const responseHeaders = new Headers(response.headers);
      responseHeaders.delete('Set-Cookie');
      responseHeaders.delete('Cookie');
      
      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: responseHeaders
      });
    } catch (error) {
      console.error('Fake page fetch error:', error);
      return new Response('Service Unavailable', { status: 502 });
    }
  },
  
  /**
   * å¤„ç†è¿æ¥æµ‹è¯•
   * @returns {Promise<Response>}
   */
  async handleConnectTest() {
    const [hostname, port] = ['cloudflare.com', 80];
    
    try {
      const socket = await connect({
        hostname: hostname,
        port: parseInt(port, 10),
      });

      const writer = socket.writable.getWriter();
      try {
        await writer.write(new TextEncoder().encode(`GET / HTTP/1.1\r\nHost: ${hostname}\r\n\r\n`));
      } finally {
        writer.releaseLock();
      }

      const reader = socket.readable.getReader();
      let value;
      
      try {
        const result = await reader.read();
        value = result.value;
      } finally {
        await reader.releaseLock();
        await socket.close();
      }

      return new Response(new TextDecoder().decode(value), { status: 200 });
    } catch (connectError) {
      return new Response(connectError.message, { status: 500 });
    }
  }
};

// ä¸»å¤„ç†å‡½æ•°
export default {
  async fetch(request, env, ctx) {
    try {
      // åˆå§‹åŒ–é…ç½®
      config.init(env);
      
      const upgradeHeader = request.headers.get('Upgrade');
      const url = new URL(request.url);
      
      // å¤„ç†WebSocketå‡çº§è¯·æ±‚
      if (upgradeHeader && upgradeHeader.toLowerCase() === 'websocket') {
        return await httpHandler.handleWebSocket(request);
      }
      
      // å¤„ç†HTTPè¯·æ±‚
      switch (url.pathname) {
        case '/':
          return httpHandler.getHomePage(request);
          
        case '/info':
          return new Response(JSON.stringify(request.cf, null, 4), {
            status: 200,
            headers: { "Content-Type": "application/json;charset=utf-8" }
          });
          
        case '/connect':
          return await httpHandler.handleConnectTest();
          
        default:
          return await httpHandler.handleFakePage(request);
      }
    } catch (err) {
      console.error('Main fetch error:', err);
      return new Response('Internal Server Error', {
        status: 500,
        headers: { 'Content-Type': 'text/plain;charset=utf-8' }
      });
    }
  },
};
